1
00:00:00,000 --> 00:00:04,000
Now I want you to implement a measurement model,

2
00:00:04,000 --> 00:00:08,000
using the function sense, that is more characteristic

3
00:00:08,000 --> 00:00:11,000
of what's often in the literature on robotics.

4
00:00:11,000 --> 00:00:14,000
Say we have a robot

5
00:00:14,000 --> 00:00:19,000
and we have a landmark, then the robot can measure the bearing, or angle,

6
00:00:19,000 --> 00:00:24,000
to this landmark relative to its own local coordinate system.

7
00:00:24,000 --> 00:00:27,000
Whereas before we measured ranges or distances,

8
00:00:27,000 --> 00:00:30,000
now we measure bearings or angles.

9
00:00:30,000 --> 00:00:33,000
We assume in the world there are 4 landmarks:

10
00:00:33,000 --> 00:00:41,000
L1, L2, L3, and L4. All of those are distinguishable.

11
00:00:41,000 --> 00:00:44,000
So the measurement vector is a set of 4 bearings

12
00:00:44,000 --> 00:00:47,000
that correspond to those four different landmarks.

13
00:00:47,000 --> 00:00:50,000
So when you implement this, I recommend you use the function

14
00:00:50,000 --> 00:00:53,000
atan2, which is the generalization of arctangent

15
00:00:53,000 --> 00:00:58,000
that takes as input delta y and then delta x.

16
00:00:58,000 --> 00:01:03,000
Atan2 would give you the orientation of a vector in global coordinates.

17
00:01:03,000 --> 00:01:07,000
We then have to adjust for the fact that it's relative to the robot's local coordinates,

18
00:01:07,000 --> 00:01:12,000
which is done by subtracting the orientation of the robot.

19
00:01:12,000 --> 00:01:19,000
This should give you the implementation of a bearing to a landmark.

20
00:01:19,000 --> 00:01:23,000
So with this implementation I add a variable called "bearing_noise".

21
00:01:23,000 --> 00:01:26,000
which you probably already used because it was already referenced before.

22
00:01:26,000 --> 00:01:31,000
I set it to 0 just so that we have no noise, and you can check your code.

23
00:01:31,000 --> 00:01:34,000
We initialize the robot coordinates as 30 and 20.

24
00:01:34,000 --> 00:01:38,000
Motions are now irrelevant.

25
00:01:38,000 --> 00:01:44,000
But as I go down, I now just actually give the following two lines of code.

26
00:01:44,000 --> 00:01:49,000
I print the robot coordinates as before, and I print the measurements.

27
00:01:49,000 --> 00:01:52,000
The robot is at 30/20, and the bearings for these landmarks will be

28
00:01:52,000 --> 00:01:59,000
6.00, 3.72, 1.92, and 0.85.

29
00:01:59,000 --> 00:02:04,000
My question for you is: can you implement the software the measures those bearings?

30
00:02:04,000 --> 00:02:08,000
If I change the initial orientation of the robot to be pi over 5,

31
00:02:08,000 --> 00:02:11,000
I now get my new robot coordinates over here,

32
00:02:11,000 --> 00:02:16,000
and my measurement vector outputs me very different values.

33
00:02:16,000 --> 00:02:18,000
And that's because this robot is now rotated

34
00:02:18,000 --> 00:02:21,000
and therefore all the bearings to the landmarks do change.

35
00:02:21,000 --> 00:02:24,000
It's 5.3, 3.1, 1.3, and 0.22.

36
00:02:24,000 --> 00:02:28,000
Implement a measurement function that gives me exactly those values.

